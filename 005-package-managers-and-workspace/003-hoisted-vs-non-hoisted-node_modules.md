## Hoisted vs Non-Hoisted node_modules 

### 1. First: why `node_modules` exists at all 

`node_modules` exists to:

- Store installed dependencies
- Allow Node.js to resolve `import` / `require` statements

Node.js resolves modules like this:

1. Look in the current folder’s `node_modules`
2. If not found, go to the parent folder
3. Keep going upward until the filesystem root

This **upward search behavior** is the root cause of hoisting.

---

### 2. What “hoisted node_modules” means

Hoisting means:

- Dependencies are **moved upward**
- Shared dependencies are placed in a common `node_modules`
- Usually at the repo root

Used by:

- npm (default)
- Yarn classic

Result:

- Fewer copies of dependencies
- Faster installs
- BUT looser boundaries

---

### 3. Hoisted structure 

    repo/  
     ├─ node_modules/  
     │   ├─ lodash  
     │   ├─ react  
     │   └─ zod  
     ├─ packages/  
     │   └─ auth-lib/  
     │       └─ package.json  

Here’s the key problem:

- `auth-lib` can import `lodash`
- Even if `lodash` is NOT in `auth-lib/package.json`

Why?

Because Node.js walks up the folder tree and finds it.

This is called **implicit dependency access**.

---

### 4. Why hoisting feels convenient

Hoisting feels good because it:

- Reduces disk usage
- Speeds up installs
- “Just works” most of the time
- Hides complexity from beginners

This convenience is why hoisting became the default.

---

### 5. The hidden danger of hoisting 

Hoisting allows **accidental bugs**.

Example:

You write this in `auth-lib`:

    import axios from "axios";

But:

- `auth-lib` does NOT list axios as a dependency
- Another package does
- axios is hoisted to the root

Result:

- Works locally
- CI fails
- Production fails

This is one of the **most dangerous JS failure modes**.

Why it’s bad:

- Bugs are environment-dependent
- CI failures feel random
- Refactors become scary

---

### 6. What “non-hoisted” means

Non-hoisted means:

- Each package sees ONLY its declared dependencies
- No walking upward to find “random” dependencies

Used by:

- pnpm (by default)
- Yarn Plug’n’Play (conceptually)

This enforces **strict isolation**.

---

### 7. Non-hoisted structure

    packages/auth-lib/  
     └─ node_modules/  
         └─ zod  

In this model:

- `auth-lib` can import `zod`
- It CANNOT import anything else
- Missing dependency = immediate error

This is:

- Strict
- Safe
- Predictable

---

### 8. pnpm’s hybrid approach 

pnpm does NOT fully duplicate dependencies.

Instead, pnpm uses:

- A global content-addressable store
- Hard links and symlinks
- A virtual `node_modules` layout

What this gives you:

- Isolation at runtime
- Deduplication at disk level

So you get:

- Safety of non-hoisted
- Performance of hoisted

This is why pnpm is special.

---

### 9. Practical: what pnpm’s node_modules actually looks like

You’ll see something like:

    node_modules/  
     └─ .pnpm/  
         └─ zod@3.22.4/node_modules/zod  

And inside your package:

packages/auth-lib/node_modules/zod → symlink

This means:

- The package only sees declared deps
- Files exist only once on disk
- Node.js resolution still works

It looks weird — but it’s correct.

---

### 10. Practical strictness example 

1. In a pnpm workspace package, write:

        import axios from "axios";

2. Do NOT add axios to `package.json`
3. Run the code

Result:

- Immediate runtime or build error

Now add axios properly:

    pnpm --filter auth-lib add axios

Run again:

- Works

This is pnpm protecting you.

---

### 11. Why pnpm’s approach is superior for monorepos

pnpm guarantees:

- No hidden dependencies
- No accidental coupling
- Deterministic installs
- Predictable CI
- Safe refactoring

Monorepos **depend on correctness more than convenience**.

pnpm enforces that correctness.

---

### 12. Common beginner confusion 

Many beginners see pnpm’s layout and think:

- “This is broken”
- “This is messy”
- “Why is node_modules so weird?”

Reality:

- It’s intentionally designed
- It matches dependency declarations exactly
- It prevents entire classes of bugs

Trust the structure.

---

### One-sentence takeaway 

Hoisted node_modules are convenient but unsafe, while non-hoisted (pnpm-style) structures enforce correctness and prevent hidden dependencies — which is critical for monorepos.
